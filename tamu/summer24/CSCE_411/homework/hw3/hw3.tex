\documentclass{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{fancyhdr}
\usepackage{enumerate}
\usepackage[ruled]{algorithm2e}
\usepackage{geometry}[margin=1in]

\pagestyle{fancy}
\fancyhf{}
\lhead{3rd Homework - CSCE 411 700}
\rhead{Kevin Lei}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\arraystretch}{1.2}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}

\begin{document}

\section{Main Idea}
In this problem, we are given three containers with sizes $A$, $B$, and $C$ pints where $A, B, C \in \mathbb{Z}^+$.
The $A$ pint container initially has $a$ pints of water, the $B$ pint container initially has $b$ pints of water, and the $C$ pint container initially has $c$ pints of water for $a, b, c \in \mathbb{Z}^+ \cup \{0\}$.
We want to determine if it is possible to leave exacty $k$ pints of water in one of the containers after performing a sequence of pouring operations, where we can only stop pouring when the source container is empty or the destination container is full.

We can model this problem as a graph $G = (V, E)$ where $V$ is the set of all possible states of the three containers and $E$ is the set of all possible transitions between states.
Each state is a triple $(\alpha, \beta, \gamma)$ where $\alpha$ is the number of pints in the $A$ pint container, $\beta$ is the number of pints in the $B$ pint container, and $\gamma$ is the number of pints in the $C$ pint container.
It should hold that, $\alpha + \beta + \gamma$ remains constant throughout the entire sequence of pouring operations, being equal to the initial sum $a + b + c$.
An edge $(u, v) \in E$ if and only if it is possible to pour water from state $u$ to state $v$, following the rules mentioned before.
Then the question becomes whether there is a path from the initial state $(a, b, c)$ to a state $(\alpha, \beta, \gamma)$ such that any of $\alpha$, $\beta$, or $\gamma$ is equal to $k$.

The upshot of the algorithm that solves this efficiently is that we can use breadth-first search to traverse the graph $G$.
First, we initialize a queue $Q$ and a set $S$ to store visited states.
We start by adding the initial state $(a, b, c)$ to $Q$ and $S$.
Then, until $Q$ is empty, we dequeue a state $(\alpha, \beta, \gamma)$ from $Q$ and check if any of $\alpha$, $\beta$, or $\gamma$ is equal to $k$.
If so, we return true.
Otherwise, we generate all possible states that can be reached from $(\alpha, \beta, \gamma)$.
For each of these states, we check if it has been visited before.
If not, we add it to $Q$ and $S$.
Finally, if we have exhausted all possible states without finding a solution, we return false.

\section{Pseudocode}

\begin{algorithm}[H]
\caption{Pouring Water}
\KwIn{Container sizes $A$, $B$, $C$; initial water levels $a$, $b$, $c$; target water level $k$}
\KwOut{True if it is possible to leave exactly $k$ pints of water in one of the containers, false otherwise}
Initialize an empty queue $Q$ and an empty set $S$\;
Enqueue $(a, b, c)$ into $Q$ and add $(a, b, c)$ to $S$\;
\While{$Q$ is not empty}{
    Dequeue $(\alpha, \beta, \gamma)$ from $Q$\;
    \If{$\alpha = k$ or $\beta = k$ or $\gamma = k$}{
        \Return{True}\;
    }
    \For {$(\alpha', \beta', \gamma')$ in Generate($\alpha, \beta, \gamma$)}{
        \If{$(\alpha', \beta', \gamma') \notin S$}{
            Enqueue $(\alpha', \beta', \gamma')$ into $Q$ and add $(\alpha', \beta', \gamma')$ to $S$\;
        }
    }
}
\Return{False}\;
\end{algorithm}

\begin{algorithm}[H]
\caption{Generate}
\KwIn{Current state $(\alpha, \beta, \gamma)$, Container sizes $A$, $B$, $C$}
\KwOut{List of all possible next states}
Initialize an empty list NextStates\;
$x = \min(\alpha, B - \beta)$\;
\If{$x > 0$}{
Add $(\alpha - x, \beta + x, \gamma)$ to NextStates;
}
$x = \min(\alpha, C - \gamma)$\;
\If{$x > 0$}{
Add $(\alpha - x, \beta, \gamma + x)$ to NextStates;
}
$x = \min(\beta, A - \alpha)$\;
\If{$x > 0$}{
Add $(\alpha + x, \beta - x, \gamma)$ to NextStates;
}
$x = \min(\beta, C - \gamma)$\;
\If{$x > 0$}{
Add $(\alpha, \beta - x, \gamma + x)$ to NextStates;
}
$x = \min(\gamma, A - \alpha)$\;
\If{$x > 0$}{
Add $(\alpha + x, \beta, \gamma - x)$ to NextStates;
}
$x = \min(\gamma, B - \beta)$\;
\If{$x > 0$}{
Add $(\alpha, \beta + x, \gamma - x)$ to NextStates;
}
\Return{NextStates};
\end{algorithm}

\section{Proof of Correctness}

To prove the correctness of our algorithm, we will first prove the correctness of the Generate function, and then use this to prove the correctness of the main Pouring Water algorithm.

\subsection{Correctness of the Generate Function}

\begin{lemma}
The Generate function produces all and only the valid next states according to the problem rules.
\end{lemma}

\begin{proof}
We prove this lemma in two parts.
First, we want to show that all states produced are valid.
For each possible pouring pairing (e.g., from A to B), the function calculates the theoretical amount of water to pour $x = \min(\alpha, B - \beta)$, where $\alpha$ is the current amount in A and $B - \beta$ is the available space in B. 
Taking the minimum of $\alpha$ and $B - \beta$ ensures the following:

\begin{enumerate}
    \item We don't pour more water than is available in the source container.
    In the case that $\alpha < B - \beta$, the amount of water available in A is less than the space available in B. 
    Thus, the pour is valid.
    \item We don't exceed the capacity of the destination container.
    In the case that $\alpha > B - \beta$, the amount of water available in A exceeds the available space in B.
    Thus, we only pour the amount that fits in B, so the pour is valid.
\end{enumerate}

Additionally, since the water poured $x$ is always subtracted from the source container and added to the destination container, the sum of water in all containers remains constant, satisfying the problem rules.
Therefore, the states produced by the Generate function are valid according to the problem rules.
Next, we want to show that the function is exhaustive in producing all possible valid next states.
The function considers all six possible pouring operations: A to B, A to C, B to A, B to C, C to A, and C to B.
There are only two possible destination containers for each of the three possible source containers, so there are six possible operations.
This exhausts all possible single-step transitions in the problem.
Therefore, the Generate function produces all and only the valid next states.
\end{proof}

\subsection{Correctness of the Pouring Water Algorithm}

We will prove the correctness of the main algorithm using invariant maintenance, termination proof, completeness, and soundness.

\begin{theorem}
The Pouring Water algorithm correctly determines whether it is possible to leave exactly $k$ pints of water in one of the containers after a sequence of pouring operations.
\end{theorem}

\begin{proof}
First, consider the loop invariant $Q$ containing reachable unexplored states.
Upon initialization, $Q$ will contain the initial state $(a, b, c)$.
For each iteration, explored states are dequeued from $Q$ and their neighbors are enqueued, which maintains the invariant.
Then, the loop with only terminate when either $Q$ is empty or a state with $k$ pints of water is found.
The algorithm is guaranteed to find a solution if one exists, since BFS explores all possible states reachable from the initial state, and the generate function produces all valid next states by Lemma 1.
Therefore, the algorithm correctly solves the problem.
\end{proof}

\section{Runtime Analysis}

Since the number of pints of water each container can hold must be an integer, the total number of states possible for three containers of sizes $A$, $B$, and $C$ is exactly $(A + 1)(B + 1)(C + 1)$ (because contains might be empty).
In the worst case, i.e. there is no solution, the algorithm will explore all possible states.
Therefore, the runtime complexity of the algorithm is $O(ABC)$ where $A$, $B$, and $C$ are the sizes of the three containers.

\end{document}
