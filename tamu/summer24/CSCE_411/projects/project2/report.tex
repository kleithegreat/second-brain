\documentclass{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{fancyhdr}
\usepackage{enumerate}
\usepackage[ruled]{algorithm2e}

\title{Project of Algorithms on Node Labeling}
\author{Kevin Lei}
\date{August 2, 2024}

\newtheorem{theorem}{Theorem}

\begin{document}

\maketitle

\section{Introduction}

In this project we discuss the ``Node Labeling Problem'', in which we attempt to label the nodes of a graph with unique labels from a set of labels.
We have the following definitions:
\begin{itemize}
    \item Let $G = (V, E)$ be an undirected graph.
    \item Let $d(u, v)$ be the distance between nodes $u$ and $v$.
    \item For all nodes $v \in V$, let $N(v, h) \subseteq V$ be the set of nodes that are at most $h$ hops away from $v$.
    \item Let $K = \{0, 1, \ldots, k-1\}$ be the set of $k$ integers, where $k \leq |V|$.
    \item For all $v \in V$, let $c(v) \in K$ be the label of node $v$, where different nodes may have the same label.
    \item Let $C(v, h)$ be the set of labels of nodes in $N(v, h)$.
    \item A labeling of the nodes is \textit{valid} if every label in $K$ is used at least once.
    \item Let $r(v)$ be the smallest integer such that the node $v$ has all the labels in $K$ in $N(v, r(v))$.
    \item Let $m(v)$ be the smallest integer such that the node $v$ has at least $k$ nodes in $N(v, m(v))$.
\end{itemize}

Formally, our relevant sets and values can be defined as follows:
\begin{align*}
    N(v, h) &\triangleq \{u \in V \mid d(u, v) \leq h\} \\
    C(v, h) &\triangleq \{c(u) \mid u \in N(v, h)\} \\
    r(v) &\triangleq \min\{h \mid |C(v, h)| = k\} \\
    m(v) &\triangleq \min\{h \mid |N(v, h)| \geq k\}.
\end{align*}

Note that in general, we have $|C(v, h)| \leq |N(v, h)|$, since the labels of nodes in $N(v, h)$ are not necessarily distinct, 
and $r(v) \geq m(v)$, since there must be at least one node per label but not necessarily one label per node.

\newpage\noindent
The Node-Labeling Decision Problem is defined as follows:

\vspace{1em}\noindent
Given:
\begin{itemize}
    \item An undirected graph $G = (V, E)$
    \item A set of $k \leq |V|$ labels $K = \{0, 1, \ldots, k-1\}$
    \item A nonnegative integer $R$,
\end{itemize}
does there exist a labeling $c(v)$ for all $v \in V$ such that $|C(v, R)| = k$ for all $v \in V$?

\vspace{1em}\noindent
Now consider this as an optimization problem.
The Node-Labeling Optimization Problem is defined as follows:

\vspace{1em}\noindent
Given:
\begin{itemize}
    \item An undirected graph $G = (V, E)$
    \item A set of $k \leq |V|$ labels $K = \{0, 1, \ldots, k-1\}$,
\end{itemize}
find a valid labeling for all the nodes such that $\max_{v \in V} \frac{r(v)}{m(v)}$ is minimized.

\vspace{1em}

In the case of the optimization problem, if an algorithm that solves it has $\max_{v \in V} \frac{r(v)}{m(v)} \leq \rho$ for all possible instances, 
then we say that the algorithm has a \textit{proximity ratio} of $\rho$, and the algorithm is a $\rho$-proximity algorithm.

\vspace{1em}

First, we will prove that the Node-Labeling Decision Problem is NP-Complete.
Then, we will present a polynomial-time algorithm for the Node-Labeling Optimization Problem where the graph is a tree,
analyze the proximity ratio of the algorithm, and finally analyze the runtime complexity of the algorithm.

\section{NP-Completeness Proof}

\begin{theorem}
    The Node-Labeling Decision Problem is NP-Complete.
\end{theorem}

\begin{proof}
    A problem is NP-Complete if it is in NP and every problem in NP can be reduced to it in polynomial time.
    We will show the former by presenting a polynomial time algorithm to verify a solution to the Node-Labeling Decision Problem,
    and the latter by reducing k-coloring to the Node-Labeling Decision Problem.
    
    First, consider the following algorithm to verify a solution to the Node-Labeling Decision Problem:

    \begin{algorithm}[H]
        \caption{Verify a Solution to the Node-Labeling Decision Problem}
        \KwIn{An undirected graph $G = (V, E)$, a set of $k \leq |V|$ labels $K = \{0, 1, \ldots, k-1\}$, a nonnegative integer $R$, and a labeling $c: V \to K$}
        \KwOut{True if the labeling is valid and $|C(v, R)| = k$ for all $v \in V$, False otherwise}
        \BlankLine
        
        \For{$v \in V$}{
            $l = \emptyset$
            
            \If{$\neg$ BFS($v$, $0$, $l$)}{
                \Return False
            }
        }
        \Return True
    \end{algorithm}
    
    \begin{algorithm}[H]
        \caption{BFS}
        \KwIn{A node $v$, current depth $d$, set of labels seen $l$}
        \KwOut{True if all $k$ labels are seen within depth $R$, False otherwise}
        \BlankLine
        \If{$d > R$}{
            \Return False
        }
        $l = l \cup \{c(v)\}$
        \If{$|l| = k$}{
            \Return True
        }
        \For{each neighbor $u$ of $v$}{
            \If{BFS($u$, $d + 1$, $l$)}{
                \Return True
            }
        }
        \Return False
    \end{algorithm}
    
    This algorithm works by performing a breadth-first search from each node $v$ in the graph,
    and checking if all $k$ labels are seen within depth $R$.
    If a depth of $R$ is reached without seeing all $k$ labels, the algorithm returns False.
    Otherwise, the algorithm returns True.
    The algorithm runs in $O(|V| \cdot (|V| + |E|))$ time, which is polynomial in the size of the input.
    Thus, the Node-Labeling Decision Problem is in NP.

    Now we perform a reduction from the 3-coloring problem to the Node-Labeling Decision Problem.
    Let $G' = (V', E')$ be an instance of the 3-coloring problem.
    We can construct an instance of the node labeling problem $(G=(V, E), K, R)$ as follows:
    \begin{itemize}
        \item $V = V'$
        \item $E = E'$
        \item $K = \{0, 1, 2\}$
        \item $R = 2$
    \end{itemize}
    This transformation can be done in polynomial time, since we only copy the graph and set $K$ and $R$ to constant values.
    We claim that $G'$ is 3-colorable if and only if $G$ has a valid labeling such that $|C(v, R)| = 3$ for all $v \in V$.

    \paragraph{$(\Rightarrow)$} Assume that $G'$ is 3-colorable.
    Then there exists some valid 3-coloring $c': V' \to \{0, 1, 2\}$ of $G'$.
    Let $c: V \to K$ be the labeling of $G$ such that $c(v) = c'(v)$ for all $v \in V'$.
    Since $c'$ is a valid 3-coloring, it uses all the colors, so $c$ will also be a valid labeling of $G$.
    Then, for all $v \in V$, $N(v, 2)$ must contain at least 3 nodes, so in order for the labeling to be valid, at least 3 distinct labels must be used.
    Thus, $|C(v, 2)| = 3$ for all $v \in V$.

    \paragraph{$(\Leftarrow)$} Assume that there exists a valid labeling $c: V \to K$ of $G$ such that $|C(v, 2)| = 3$ for all $v \in V$.
    We can use the same coloring $c'$ of $G'$ such that $c'(v) = c(v)$ for all $v \in V'$.
    For all edges $(u, v) \in E'$, we have that $u \in N(v, 2)$ and $v \in N(u, 2)$.
    Since $|C(u, 2)| = 3$ and $|C(v, 2)| = 3$, we have that $c'(u) \neq c'(v)$, or else one of them would only see 2 distinct labels in 2 hops.
    Thus, $c'$ is a valid 3-coloring of $G'$.
    
    \vspace{1em}
    Now we have shown that the Node-Labeling Decision Problem is in NP and that the 3-coloring problem can be reduced to it in polynomial time.
    Therefore, the Node-Labeling Decision Problem is also NP-hard, and thus NP-Complete.
\end{proof}

\section{Approximation Algorithm}

Here we discuss an algorithm to solve the Node-Labeling \textit{Optimization} Problem when the input graph is a tree.


\section{Pseudocode}

\begin{algorithm}[H]
    \caption{Node Labeling Algorithm for Trees}
    \KwIn{A tree $T = (V, E)$, number of labels $k$}
    \KwOut{A labeling $c: V \to \{0, 1, \ldots, k-1\}$ that minimizes $\max_{v \in V} \frac{r(v)}{m(v)}$}
    \BlankLine
    
    Initialize $c(v) \gets -1$ for all $v \in V$\;
    Initialize queue $Q \gets \emptyset$\;
    Choose an arbitrary root node $r \in V$\;
    $Q$.enqueue($r$)\;
    
    \While{$Q$ is not empty}{
        $v \gets Q$.dequeue()\;
        $L \gets$ set of unused labels in $\{0, 1, \ldots, k-1\}$\;
        \If{$L$ is empty}{
            $L \gets \{0, 1, \ldots, k-1\}$\;
        }
        $c(v) \gets$ random label from $L$\;
        \For{each child $u$ of $v$}{
            $Q$.enqueue($u$)\;
        }
    }
    
    \While{true}{
        Initialize $ratios \gets \emptyset$\;
        \For{each $v \in V$}{
            Compute $r(v)$ and $m(v)$ using BFS\;
            $ratios[v] \gets r(v) / m(v)$\;
        }
        $max\_ratio \gets \max(ratios)$\;
        \If{$max\_ratio = 1.0$}{
            \Return $c$\;
        }
        $worst\_nodes \gets \{v \in V \mid ratios[v] = max\_ratio\}$\;
        $v \gets$ random node from $worst\_nodes$\;
        $N_v \gets$ nodes within $\lceil max\_ratio \rceil$ hops of $v$\;
        $label\_counts \gets$ count of each label in $N_v$\;
        $most\_common \gets$ label with highest count in $label\_counts$\;
        $least\_common \gets$ label with lowest count in $label\_counts$\;
        $nodes\_to\_swap \gets \{u \in N_v \mid c(u) = most\_common\}$\;
        $node\_to\_swap \gets \argmax_{u \in nodes\_to\_swap}(ratios[u])$\;
        $c(node\_to\_swap) \gets least\_common$\;
    }
    \end{algorithm}

\section{Proximity Ratio Analysis}



\section{Runtime Complexity Analysis}



\end{document}
